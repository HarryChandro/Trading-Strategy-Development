import yfinance as yf
import mplfinance as mpf
import pandas as pd
import numpy as np
import optuna
from matplotlib import pyplot as plt
from matplotlib import patches as mpatches
from datetime import datetime, timedelta
import pytz

# Suppress Optuna logs for cleaner output
optuna.logging.set_verbosity(optuna.logging.WARNING)

ticker = "IXHL"

def full_data():
    try:
        # Getting final datapoint
        start_date = datetime(2025, 9, 30)  
        end_date = datetime.now() + timedelta(days=1)    
        
        print(f"Requesting data from {start_date.date()} to {end_date.date()}")
        
        data = yf.download(
            ticker,
            start=start_date.strftime('%Y-%m-%d'),
            end=end_date.strftime('%Y-%m-%d'),
            interval="1m",
            progress=False,
            auto_adjust=True,
            prepost=True
        )
        
        # Debug info
        if not data.empty:
            print(f"Data retrieved: {len(data)} rows")
            print(f"Date range: {data.index[0]} to {data.index[-1]}")
            print(f"Unique dates: {sorted(set(data.index.date))}")
            
            # Check specifically for Aug 22 data
            all_data = data[data.index.date == pd.Timestamp('2025-10-01').date()]
            print(f"August 22 data points: {len(all_data)}")
        else:
            print("No data retrieved - empty DataFrame")
            
        return data
    
    except Exception as e:
        print(f"Error fetching data: {e}")
        return None

# Get data with error handling
data = full_data()

if data is None or data.empty:
    print("Failed to fetch data. Please check your internet connection or try different dates.")
    exit()

print(f"\n=== DATA ANALYSIS ===")
print(f"Data available from {data.index[0]} to {data.index[-1]}")
print(f"Number of data points: {len(data)}")

# Get current time in UK timezone
uk_tz = pytz.timezone('Europe/London')
current_time_uk = datetime.now(uk_tz)
print(f"Current UK time: {current_time_uk.strftime('%Y-%m-%d %H:%M:%S %Z%z')}")

# Check what dates we have data for
data_dates = sorted(set([pd.Timestamp(ts).date() for ts in data.index]))
print(f"Dates with data: {[d.strftime('%Y-%m-%d') for d in data_dates]}")

# Check specifically for today's data
today_uk = current_time_uk.date()
today_data = data[data.index.date == today_uk]
print(f"Data points for today ({today_uk}): {len(today_data)}")

if len(today_data) > 0:
    print(f"Today's trading hours: {today_data.index[0].strftime('%H:%M')} to {today_data.index[-1].strftime('%H:%M')}")
else:
    print(" No data available for today")
    print("Possible reasons:")
    print("1. Yahoo Finance data delay (can be 15-60 minutes behind)")
    print("2. Stock not actively traded today")
    print("3. Data provider issues")
    print("4. Different trading hours on Trading 212 vs actual exchange")
    
    # Check if we should have data based on UK trading hours (8 AM - 4:30 PM)
    current_hour_uk = current_time_uk.hour
    if 8 <= current_hour_uk <= 16.5:  # UK trading hours typically 8:00-16:30
        print("UK markets should be open now - data should be available")
    else:
        print("Outside UK trading hours")

# Check data frequency and quality
try:
    freq = pd.infer_freq(data.index)
    print(f"Data frequency: {freq}")
except:
    print("Data frequency: Could not determine")

print(f"Data columns: {list(data.columns)}")

# Clean and prepare data
if isinstance(data.columns, pd.MultiIndex):
    data.columns = ['_'.join(col).strip() for col in data.columns]
    column_mapping = {}
    for col in data.columns:
        if 'Open' in col: column_mapping[col] = 'Open'
        elif 'High' in col: column_mapping[col] = 'High'
        elif 'Low' in col: column_mapping[col] = 'Low'
        elif 'Close' in col: column_mapping[col] = 'Close'
        elif 'Volume' in col: column_mapping[col] = 'Volume'
    data.rename(columns=column_mapping, inplace=True)

standard_cols = ['Open', 'High', 'Low', 'Close', 'Volume']
available_cols = [col for col in standard_cols if col in data.columns]
data = data[available_cols]

# Calculate RSI
def calculate_rsi(data, period=7):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

data['RSI'] = calculate_rsi(data)

data = data.dropna()

# Backtest function with RSI strategy and stop loss
def backtest_rsi_strategy(data, overbought_level, oversold_level, stop_loss_pct=0.03, initial_capital=200):
    # Generate signals
    data = data.copy()
    data['Signal'] = 0
    data['Position'] = 0

    # RSI-based signals
    data.loc[data['RSI'] < oversold_level, 'Signal'] = 1  # Buy signal
    data.loc[data['RSI'] > overbought_level, 'Signal'] = -1  # Sell signal

    # Calculate trade performance with initial capital tracking and stop loss
    trades = []
    entry_price = None
    entry_date = None
    stop_loss_price = None
    current_capital = initial_capital
    capital_history = [{'Date': data.index[0], 'Capital': current_capital}]
    units = 0
    position = 0  # 0 = no position, 1 = long position

    for i in range(len(data)):
        current_low = data['Low'].iloc[i]
        current_high = data['High'].iloc[i]
        current_close = data['Close'].iloc[i]
        current_date = data.index[i]
        
        # Check for stop loss trigger first if in a position
        if position == 1 and entry_price is not None and current_low <= stop_loss_price:
            # Stop loss triggered
            exit_price = stop_loss_price
            exit_date = current_date
            
            # Calculate returns based on units purchased
            returns = (exit_price - entry_price) / entry_price * 100
            capital_gain = units * (exit_price - entry_price)
            current_capital = units * exit_price  # Update portfolio
            
            trades.append({
                'Entry Date': entry_date,
                'Exit Date': exit_date,
                'Entry Price': entry_price,
                'Exit Price': exit_price,
                'Units': units,
                'Return': returns,
                'Capital Gain': capital_gain,
                'Ending Capital': current_capital,
                'Success': returns > 0,
                'Stop Loss Hit': True
            })
            
            capital_history.append({'Date': exit_date, 'Capital': current_capital, 'Action': 'STOP LOSS'})
            
            # Reset position
            entry_price = None
            entry_date = None
            stop_loss_price = None
            units = 0
            position = 0
        
        # Check for regular exit signal (if in a position and not stopped out)
        if position == 1 and data['Signal'].iloc[i] == -1 and entry_price is not None:
            exit_price = current_close
            exit_date = current_date
            
            # Calculate returns based on units purchased
            returns = (exit_price - entry_price) / entry_price * 100
            capital_gain = units * (exit_price - entry_price)
            current_capital = units * exit_price  # Update capital
            
            trades.append({
                'Entry Date': entry_date,
                'Exit Date': exit_date,
                'Entry Price': entry_price,
                'Exit Price': exit_price,
                'Units': units,
                'Return': returns,
                'Capital Gain': capital_gain,
                'Ending Capital': current_capital,
                'Success': returns > 0,
                'Stop Loss Hit': False
            })
            
            capital_history.append({'Date': exit_date, 'Capital': current_capital, 'Action': 'SELL'})
            
            # Reset position
            entry_price = None
            entry_date = None
            stop_loss_price = None
            units = 0
            position = 0
        
        # Check for entry signal (if not in a position)
        if position == 0 and data['Signal'].iloc[i] == 1 and current_capital > 0:
            # Entry signal
            entry_price = current_close
            entry_date = current_date
            units = current_capital / entry_price  # Calculate how many units we can buy
            stop_loss_price = entry_price * (1 - stop_loss_pct)
            position = 1  # Set position to long
            
            capital_history.append({'Date': entry_date, 'Capital': current_capital, 'Action': 'BUY'})

    # If still in a position at the end of data, calculate unrealized PnL
    if position == 1 and entry_price is not None:
        exit_price = data['Close'].iloc[-1]
        exit_date = data.index[-1]
        returns = (exit_price - entry_price) / entry_price * 100
        capital_gain = units * (exit_price - entry_price)
        current_capital = units * exit_price
        
        # Check if stop loss would have been hit
        stop_loss_hit = exit_price <= stop_loss_price if stop_loss_price is not None else False
        
        trades.append({
            'Entry Date': entry_date,
            'Exit Date': exit_date,
            'Entry Price': entry_price,
            'Exit Price': exit_price,
            'Units': units,
            'Return': returns,
            'Capital Gain': capital_gain,
            'Ending Capital': current_capital,
            'Success': returns > 0,
            'Stop Loss Hit': stop_loss_hit,
            'Unrealized': True
        })
        
        capital_history.append({'Date': exit_date, 'Capital': current_capital, 'Action': 'SELL (Unrealized)'})

    # Calculate performance metrics
    if trades:
        trades_df = pd.DataFrame(trades)
        total_trades = len(trades_df)
        successful_trades = len(trades_df[trades_df['Success'] == True])
        stop_loss_trades = len(trades_df[trades_df['Stop Loss Hit'] == True])
        success_rate = successful_trades / total_trades * 100 if total_trades > 0 else 0
        stop_loss_rate = stop_loss_trades / total_trades * 100 if total_trades > 0 else 0
        avg_return = trades_df['Return'].mean() if total_trades > 0 else 0
        
        # Calculate total return based on initial capital
        total_return = (current_capital - initial_capital) / initial_capital * 100
        
        # Calculate max drawdown
        capital_df = pd.DataFrame(capital_history)
        capital_df['Peak'] = capital_df['Capital'].cummax()
        capital_df['Drawdown'] = (capital_df['Capital'] - capital_df['Peak']) / capital_df['Peak'] * 100
        max_drawdown = capital_df['Drawdown'].min()
        
        return {
            'total_trades': total_trades,
            'success_rate': success_rate,
            'stop_loss_rate': stop_loss_rate,
            'avg_return': avg_return,
            'total_return': total_return,
            'ending_capital': current_capital,
            'max_drawdown': max_drawdown,
            'trades': trades,
            'capital_history': capital_history
        }
    else:
        return {
            'total_trades': 0,
            'success_rate': 0,
            'stop_loss_rate': 0,
            'avg_return': 0,
            'total_return': 0,
            'ending_capital': initial_capital,
            'max_drawdown': 0,
            'trades': [],
            'capital_history': capital_history
        }

# Objective function for Optuna optimization
def objective(trial):
    # Suggest overbought and oversold levels
    overbought_level = trial.suggest_int('overbought_level', 60, 90)
    oversold_level = trial.suggest_int('oversold_level', 10, 40)
    
    # Ensure overbought level is higher than oversold level
    if overbought_level <= oversold_level:
        return 0
    
    # Run backtest with £200 initial capital and 20% stop loss
    results = backtest_rsi_strategy(data, overbought_level, oversold_level, 
                                   stop_loss_pct=0.2, initial_capital=200)
    
    # We want to maximize total return while having a reasonable number of trades
    # Penalize strategies with too few trades
    if results['total_trades'] < 3:
        return 0
    
    # Calculate score: total return adjusted by success rate
    score = results['total_return'] * (1 + results['success_rate'] / 100)
    
    return score

# Run optimization
print("Running optimization to find best RSI levels...")
study = optuna.create_study(direction='maximize')
study.optimize(objective, n_trials=50)  # Reduced trials for faster execution

# Get best parameters
best_params = study.best_params
best_overbought = best_params['overbought_level']
best_oversold = best_params['oversold_level']
best_value = study.best_value

print("\n" + "="*60)
print("OPTIMAL RSI LEVELS FOUND")
print("="*60)
print(f"Best Overbought Level: {best_overbought}")
print(f"Best Oversold Level: {best_oversold}")
print(f"Best Score: {best_value:.2f}")

# Run backtest with optimal parameters
print("\n" + "="*60)
print("PERFORMANCE WITH OPTIMAL PARAMETERS (3% STOP LOSS)")
print("="*60)
optimal_results = backtest_rsi_strategy(data, best_overbought, best_oversold, 
                                      stop_loss_pct=0.03, initial_capital=200)

print(f"Initial Capital: £200.00")
print(f"Ending Capital: £{optimal_results['ending_capital']:.2f}")
print(f"Total Return: {optimal_results['total_return']:.2f}%")
print(f"Total Trades: {optimal_results['total_trades']}")
print(f"Success Rate: {optimal_results['success_rate']:.2f}%")
print(f"Stop Loss Hit Rate: {optimal_results['stop_loss_rate']:.2f}%")
print(f"Average Return per Trade: {optimal_results['avg_return']:.2f}%")
print(f"Maximum Drawdown: {optimal_results['max_drawdown']:.2f}%")

# Print individual trades
if optimal_results['trades']:
    print("\nINDIVIDUAL TRADES:")
    for i, trade in enumerate(optimal_results['trades']):
        status = "UNREALIZED" if 'Unrealized' in trade and trade['Unrealized'] else "CLOSED"
        stop_loss_info = " (STOP LOSS)" if trade['Stop Loss Hit'] else ""
        print(f"Trade {i+1}: {status}{stop_loss_info}")
        print(f"  Entry: {trade['Entry Date'].strftime('%Y-%m-%d %H:%M')} at ${trade['Entry Price']:.2f}")
        print(f"  Exit: {trade['Exit Date'].strftime('%Y-%m-%d %H:%M')} at ${trade['Exit Price']:.2f}")
        print(f"  Units: {trade['Units']:.4f}")
        print(f"  Return: {trade['Return']:.2f}%")
        print(f"  P&L: £{trade['Capital Gain']:.2f}")
        print(f"  Capital after trade: £{trade['Ending Capital']:.2f}")
        print()

# Prepare data for plotting with optimal parameters
plot_data = data.copy()
plot_data['Signal'] = 0
plot_data['Position'] = 0

# RSI-based signals with optimal levels
plot_data.loc[plot_data['RSI'] < best_oversold, 'Signal'] = 1  # Buy signal
plot_data.loc[plot_data['RSI'] > best_overbought, 'Signal'] = -1  # Sell signal

# Create positions for visualisation only
position = 0
for i in range(len(plot_data)):
    if plot_data['Signal'].iloc[i] == 1 and position == 0:
        plot_data.iloc[i, plot_data.columns.get_loc('Position')] = 1
        position = 1
    elif plot_data['Signal'].iloc[i] == -1 and position == 1:
        plot_data.iloc[i, plot_data.columns.get_loc('Position')] = -1
        position = 0
    else:
        plot_data.iloc[i, plot_data.columns.get_loc('Position')] = 0

# Get start and end dates for title
start_date = plot_data.index[0].strftime('%Y-%m-%d')
end_date = plot_data.index[-1].strftime('%Y-%m-%d')

# Create arrays for buy/sell signals that match the length of the data
buy_signals = pd.Series(np.nan, index=plot_data.index)
sell_signals = pd.Series(np.nan, index=plot_data.index)

buy_idx = plot_data[plot_data['Position'] == 1].index
sell_idx = plot_data[plot_data['Position'] == -1].index

if not buy_idx.empty:
    buy_signals.loc[buy_idx] = plot_data.loc[buy_idx, 'Close']  # Show on closing price
    
if not sell_idx.empty:
    sell_signals.loc[sell_idx] = plot_data.loc[sell_idx, 'Close']  # Show on closing price

# Create additional plots
apds = [
    mpf.make_addplot(plot_data['RSI'], panel=1, color='purple', ylabel='RSI'),
    mpf.make_addplot([best_overbought] * len(plot_data), panel=1, color='red', linestyle='--', alpha=0.7),
    mpf.make_addplot([best_oversold] * len(plot_data), panel=1, color='green', linestyle='--', alpha=0.7),
]

# Add markers for buy and sell signals directly on candles
if not buy_idx.empty:
    apds.append(mpf.make_addplot(buy_signals, 
                                scatter=True, 
                                markersize=100, 
                                marker='^', 
                                color='lime',
                                panel=0))
if not sell_idx.empty:
    apds.append(mpf.make_addplot(sell_signals, 
                                scatter=True, 
                                markersize=100, 
                                marker='v', 
                                color='red',
                                panel=0))

# Create custom style
mc = mpf.make_marketcolors(up='g', down='r')
s = mpf.make_mpf_style(marketcolors=mc, gridstyle=':')

# Plot candlestick chart with RSI and signals
fig, axes = mpf.plot(
    plot_data,
    type='candle',
    style=s,
    title=f'{ticker} Price with Optimal RSI Signals\n{start_date} to {end_date}',
    volume=False,
    figratio=(12, 8),
    ylabel='Price (USD)',
    addplot=apds,
    returnfig=True
)

green_patch = mpatches.Patch(color='green', label=f'Buy Signal (RSI < {best_oversold})')
red_patch = mpatches.Patch(color='red', label=f'Sell Signal (RSI > {best_overbought})')
axes[0].legend(handles=[green_patch, red_patch], loc='upper left')

# Add text box with performance summary
performance_text = f"Initial: £200.00\nEnding: £{optimal_results['ending_capital']:.2f}\nTotal Return: {optimal_results['total_return']:.1f}%\nSuccess Rate: {optimal_results['success_rate']:.1f}%\nStop Loss Rate: {optimal_results['stop_loss_rate']:.1f}%"
axes[0].text(0.02, 0.02, performance_text, transform=axes[0].transAxes, 
            bbox=dict(boxstyle="round,pad=0.3", facecolor="white", alpha=0.7),
            verticalalignment='bottom')

# Add RSI levels to the RSI panel
axes[2].text(0.02, 0.95, f"Overbought: {best_overbought}", transform=axes[2].transAxes, 
            bbox=dict(boxstyle="round,pad=0.3", facecolor="red", alpha=0.3),
            verticalalignment='top')
axes[2].text(0.02, 0.05, f"Oversold: {best_oversold}", transform=axes[2].transAxes, 
            bbox=dict(boxstyle="round,pad=0.3", facecolor="green", alpha=0.3),
            verticalalignment='bottom')

plt.show()

# Create capital growth chart
capital_df = pd.DataFrame(optimal_results['capital_history'])
capital_df.set_index('Date', inplace=True)

plt.figure(figsize=(12, 6))
plt.plot(capital_df.index, capital_df['Capital'], label='Portfolio Value', linewidth=2)
plt.axhline(y=200, color='r', linestyle='--', alpha=0.7, label='Initial Capital (£200)')
plt.title('Portfolio Value Over Time')
plt.xlabel('Date')
plt.ylabel('Portfolio Value (£)')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

optuna.visualization.plot_optimization_history(study).show()
